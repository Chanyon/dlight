import {View, toEls} from "@dlightjs/dlight"


export class Transition extends View {
    @Prop duration: string | number = 1
    transition = typeof this.duration === "string" ? this.duration : `all ${this.duration}s`

    @State prevElInfos

    getElInfos = () => {
        return toEls(this._$children).reduce((acc, el) => {
            // ---- 这时候新el已经到新位置了，直接transform置空，拿到真实位置
            el.style.transform = ""
            acc.set(el, {
                rect: el.getBoundingClientRect(),
                stopTrigger: false
            })
            return acc
        }, new Map())
    }

    didMount() {
        setTimeout(() => {
            this.prevElInfos = this.getElInfos()
        }, 0)
    }

    Body() {
        Node(this.flag && @{
            div("ok")
        })
        {{this._$children}}
            .deepLoopEl(true)
            ._transition(`all ${this.duration}s, transform 0s`)
            .onUpdateNodes((prevNodes, nodes)=> {
                const currElInfos = this.getElInfos()
                for (let [el, prevEl] of this.prevElInfos.entries()) {
                    if (currElInfos.has(el)) {
                        // ---* 原来有，就移动。逻辑非常非常绕
                        // ---- 让上一次如果没有进行完的动画提前停止
                        prevEl.stopTrigger = true
                        const currEl = currElInfos.get(el)
                        // ---- 由于prevEl.rect的位置一直在更新，
                        //      最终的结果就是element已经在当前位置，
                        //      transform从目标位置到当前位置，所以是 prev - curr
                        const moveX = prevEl.rect.x - currEl.rect.x
                        const moveY = prevEl.rect.y - currEl.rect.y
                        moveElement(el, this.duration, moveX, moveY, currEl)
                    } else {
                        // ---- 原来没有，就appear
                        el.style.opacity = "0"
                        setTimeout(() => {
                            el.style.opacity = "1"
                        }, 0)
                    }

                }
                this.prevElInfos = currElInfos
            })
            .didMount((node) => {
                for (let el of node._$el) {
                    el.style.opacity = "0"
                    setTimeout(() => {
                        el.style.opacity = ""
                    }, 0)
                }
            })
    }
}


// TODO 这里requestAnimationFrame会中断transition，所以想着把所有的transition都转成rAF
//      就是找到现在存在的prop，然后看是不是支持，支持就getComputedStyle然后match数字一点点转过来
// ---- 太牛逼了
function moveElement(element: HTMLElement, duration: number, moveX: number, moveY: number, currEl: {rect: any, stopTrigger: boolean}) {
    let start: number | undefined, previousTimeStamp: number | undefined
    let done = false
    function step(timestamp: number) {
        if (start === undefined) {
            start = timestamp
        }
        const elapsed = timestamp - start;

        if (previousTimeStamp !== timestamp) {
            const percentTime = elapsed / (duration * 1000)
            const goX = percentTime * moveX
            const goY = percentTime * moveY

            if (percentTime >= 1) {
                element.style.transform = ""
                done = true
            } else {
                element.style.transform = `translate(${moveX - goX}px, ${moveY - goY}px)`
                // ---- 实时更新现在的位置
                currEl.rect = element.getBoundingClientRect()
            }
        }

        previousTimeStamp = timestamp
        // ---- 正常结束 或者 让上一次如果没有进行完的动画提前停止
        if (!done && !currEl.stopTrigger) {
            requestAnimationFrame(step)
        } else {
            // element.style.transition = `all ${duration}s`
        }
    }
    requestAnimationFrame(step)
}
