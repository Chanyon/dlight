import {View, toEls, Exp, Prop, State} from "@dlightjs/dlight"

type TransitionPropSub<T> = T | ((el: HTMLElement) => T) 
type TransitionProp<T> = TransitionPropSub<T> | ({
    appear: TransitionPropSub<T>,
    disappear: TransitionPropSub<T>,
    move: TransitionPropSub<T>
})
type StyleWith = string | {[key: string]: any}
export class Transition extends View {
    _$duration = 0.5
    _$easing = "ease-in-out"
    _$delay = 0
    @Prop duration: TransitionProp<number> = this._$duration
    @Prop easing: TransitionProp<string> = this._$easing
    @Prop delay: TransitionProp<number> = this._$delay

    parseProp(el: HTMLElement, key: string) {
        let prop = {}
        if (this[key].appear !== undefined ||
            this[key].disappear !== undefined ||
            this[key].move !== undefined ) {
            prop.appear = this[key].appear ?? this["_$"+key]
            prop.disappear = this[key].disappear ?? this["_$"+key]
            prop.move = this[key].move ?? this["_$"+key]
        } else {
            prop.appear = this[key]
            prop.disappear = this[key]
            prop.move = this[key]
        }
        for (let k in prop) {
            if (typeof prop[k] === "function") {
                prop[k] = prop[k](el) ?? this["_$"+key]
            }
        }
        return prop
    }
    _duration = (el: HTMLElement) => this.parseProp(el, "duration")
    _easing = (el: HTMLElement) => this.parseProp(el, "easing")
    _delay = (el: HTMLElement) => this.parseProp(el, "delay")

    transition = (duration: number, easing: string, delay: number) => `all ${duration}s ${easing} ${delay}s`

    @Prop appearWith: StyleWith | ((el: HTMLElement) => StyleWith) = {opacity: 0}
    @Prop disappearWith: StyleWith | ((el: HTMLElement) => StyleWith) = {opacity: 0}
    @Prop movable = true

    prevElInfos = new Map()
    removeStore?: {
        parentNode: HTMLElement,
        el: HTMLElement,
        rect: any,
        nextSibling: HTMLElement
    }

    Body() {
        Exp(this._$children)
            .onUpdateNodes(()=> {
                for (let [el, prevElInfo] of this.prevElInfos.entries()) {
                    if (this.movable) {
                        // ---- 不管怎么样先停transform
                        el.style.transform = ""
                        // ---- 如果上次还在add中，这里的prevElInfo.stopTrigger就是true
                        //      此时不进行update的移动
                        const currElInfo = {
                            rect: el.getBoundingClientRect(),
                            stopTrigger: prevElInfo.stopTrigger
                        }
                        this.prevElInfos.set(el, currElInfo)
                        if (currElInfo.stopTrigger) continue
                        // ---* 原来有，就移动。逻辑非常非常绕
                        // ---- 让上一次如果没有进行完的动画提前停止
                        prevElInfo.stopTrigger = true
                        // ---- 由于prevEl.rect的位置一直在更新，
                        //      最终的结果就是element已经在当前位置，
                        //      transform从目标位置到当前位置，所以是 prev - curr
                        const moveX = prevElInfo.rect.x - currElInfo.rect.x
                        const moveY = prevElInfo.rect.y - currElInfo.rect.y
                        moveElement(el, 
                        this._duration(el).move, this._easing(el).move, this._delay(el).move,
                        moveX, moveY, currElInfo)
                    }
                }
            })
            .didAppear((el) => {
                el.style.transition = this.transition(this._duration(el).appear, this._easing(el).appear, this._delay(el).appear)
                loopEls(el, (e)=>{
                    e.style.transition = this.transition(this._duration(e).appear, this._easing(e).appear, this._delay(e).appear)
                })
                requestAnimationFrame(() => {
                    // ---- 刚进来先设置成true，只有可以避免进来就再次移动
                    this.prevElInfos.set(el, {
                        rect: el.getBoundingClientRect(),
                        stopTrigger: true
                    })
                })
                if (!this.appearWith) return
                const prevStyle  = el.style.cssText
                changeElStyle(el, this.appearWith)
                requestAnimationFrame(() => {
                    el.setAttribute("style", prevStyle)
                    const listener =() => {
                        const elInfo = this.prevElInfos.get(el)
                        elInfo.rect = el.getBoundingClientRect()
                        elInfo.stopTrigger = false
                        el.removeEventListener("transitionend", listener)
                    }
                    el.addEventListener("transitionend", listener)
                })

            })
            .willDisappear((el) => {
                this.removeStore = {
                    el: el.cloneNode(true),
                    parentNode: el.parentNode,
                    rect: {top: el.offsetTop, left: el.offsetLeft},
                    nextSibling: el.nextSibling
                }
                this.prevElInfos.delete(el)
            })
            .didDisappear(() => {
                const {el, parentNode, rect, nextSibling} = this.removeStore!
                el.style.position = "absolute"
                el.style.margin = ""
                el.style.transform = ""
                el.style.transition = this.transition(this._duration(el).disappear, this._easing(el).disappear, this._delay(el).disappear)
                el.style.top = `${rect.top}px`
                el.style.left = `${rect.left}px`
                parentNode.insertBefore(el, nextSibling)

                requestAnimationFrame(() => {
                    const listener =() => {
                        el.removeEventListener("transitionend", listener)
                        el.remove()
                    }
                    el.addEventListener("transitionend", listener)
                    changeElStyle(el, this.disappearWith)
                })
                
            })
    }
}
function loopEls(el: HTMLElement, func: ()=>any) {
    if (el.nodeType === Node.TEXT_NODE) return
    func(el)
    for (let e of el.childNodes) {
        loopEls(e, func)
    }
}

function changeElStyle(el: HTMLElement, styleWith: StyleWith|((el: HTMLElement)=>StyleWith)) {
    if (typeof styleWith === "function") styleWith = styleWith(el)
    const prevStyle = el.style.cssText
    if (typeof styleWith === "string") {
        el.setAttribute("style", prevStyle + styleWith)
    } else {
        for (let [key, value] of Object.entries(styleWith)) {
            el.style[key as any] = value
        }
    }
}

// TODO! 这里requestAnimationFrame会中断transition
// ---- 太牛逼了
async function moveElement(element: HTMLElement, duration: number, easing: string, delay: number, moveX: number, moveY: number, currEl: {rect: any, stopTrigger: boolean}) {
    let start: number | undefined, previousTimeStamp: number | undefined
    let done = false
    const transition = `all ${duration}s ${easing} ${delay}s`
    function step(timestamp: number) {
        if (start === undefined) {
            start = timestamp
            element.style.transition = transition + ", transform 0s"
        }
        const elapsed = timestamp - start

        if (previousTimeStamp !== timestamp) {
            // ---- 有delay的时候，elapsed比delay小就相当于没开始，percentTime是0
            const percentTime = Math.max(elapsed / (duration * 1000) - delay, 0)

            const goX = percentTime * moveX
            const goY = percentTime * moveY

            if (percentTime >= 1) {
                element.style.transform = ""
                done = true
            } else {
                element.style.transform = `translate(${moveX - goX}px, ${moveY - goY}px)`
            }
            // ---- 实时更新现在的位置
            currEl.rect = element.getBoundingClientRect()
        }

        previousTimeStamp = timestamp
        // ---- 正常结束 或者 让上一次如果没有进行完的动画提前停止
        if (!done && !currEl.stopTrigger) {
            requestAnimationFrame(step)
        } else {
            element.style.transition = transition
        }
    }
    requestAnimationFrame(step)
}


