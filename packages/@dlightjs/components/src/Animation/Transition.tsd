import {View, toEls, Exp, Prop, State} from "@dlightjs/dlight"


type StyleWith = string | {[key: string]: any}
export class Transition extends View {
    @Prop duration = 0.5
    @Prop easing = "ease-in-out"
    transition = `all ${this.duration}s ${this.easing}`
    @Prop appearWith: StyleWith | (() => StyleWith) = {opacity: 0}
    @Prop disappearWith: StyleWith | (() => StyleWith) = {opacity: 0}
    @Prop movable = true

    prevElInfos = new Map()
    removeStore?: {
        parentNode: HTMLElement,
        el: HTMLElement,
        rect: any,
        nextSibling: HTMLElement
    }

    Body() {
        Exp(this._$children)
            .deepLoopEl()
            ._transition(this.transition)
            .onUpdateNodes(()=> {
                for (let [el, prevElInfo] of this.prevElInfos.entries()) {
                    if (this.movable) {
                        // ---- 不管怎么样先停transform
                        el.style.transform = ""
                        // ---- 如果上次还在add中，这里的prevElInfo.stopTrigger就是true
                        //      此时不进行update的移动
                        const currElInfo = {
                            rect: el.getBoundingClientRect(),
                            stopTrigger: prevElInfo.stopTrigger
                        }
                        this.prevElInfos.set(el, currElInfo)
                        if (currElInfo.stopTrigger) continue
                        // ---* 原来有，就移动。逻辑非常非常绕
                        // ---- 让上一次如果没有进行完的动画提前停止
                        prevElInfo.stopTrigger = true
                        // ---- 由于prevEl.rect的位置一直在更新，
                        //      最终的结果就是element已经在当前位置，
                        //      transform从目标位置到当前位置，所以是 prev - curr
                        const moveX = prevElInfo.rect.x - currElInfo.rect.x
                        const moveY = prevElInfo.rect.y - currElInfo.rect.y
                        moveElement(el, this.duration, this.transition, moveX, moveY, currElInfo)
                    }
                }
            })
            .deepLoopEl(false)
            .didAppear((el) => {
                requestAnimationFrame(() => {
                    // ---- 刚进来先设置成true，只有可以避免进来就再次移动
                    this.prevElInfos.set(el, {
                        rect: el.getBoundingClientRect(),
                        stopTrigger: true
                    })
                })
                if (!this.appearWith) return
                const prevStyle  = el.style.cssText
                changeElStyle(el, this.appearWith)
                requestAnimationFrame(() => {
                    el.setAttribute("style", prevStyle)
                    const listener =() => {
                        this.prevElInfos.set(el, {
                            rect: el.getBoundingClientRect(),
                            stopTrigger: false
                        })
                        el.removeEventListener("transitionend", listener)
                    }
                    el.addEventListener("transitionend", listener)
                })

            })
            .willDisappear((el) => {
                this.removeStore = {
                    el: el.cloneNode(true),
                    parentNode: el.parentNode,
                    rect: {top: el.offsetTop, left: el.offsetLeft},
                    nextSibling: el.nextSibling
                }
                this.prevElInfos.delete(el)
            })
            .didDisappear(() => {
                const {el, parentNode, rect, nextSibling} = this.removeStore!
                el.style.position = "absolute"
                el.style.margin = ""
                el.style.transform = ""
                el.style.transition = this.transition
                el.style.top = `${rect.top}px`
                el.style.left = `${rect.left}px`
                parentNode.insertBefore(el, nextSibling)

                requestAnimationFrame(() => {
                    changeElStyle(el, this.disappearWith)
                })
                const listener =() => {
                    el.removeEventListener("transitionend", listener)
                    el.remove()
                }
                el.addEventListener("transitionend", listener)
            })
    }
}

function changeElStyle(el: HTMLElement, styleWith: StyleWith|((el: HTMLElement)=>StyleWith)) {
    if (typeof styleWith === "function") styleWith = styleWith(el)
    const prevStyle = el.style.cssText
    if (typeof styleWith === "string") {
        el.setAttribute("style", prevStyle + styleWith)
    } else {
        for (let [key, value] of Object.entries(styleWith)) {
            el.style[key as any] = value
        }
    }
}

// TODO! 这里requestAnimationFrame会中断transition
// ---- 太牛逼了
function moveElement(element: HTMLElement, duration: number, transition: string, moveX: number, moveY: number, currEl: {rect: any, stopTrigger: boolean}) {
    let start: number | undefined, previousTimeStamp: number | undefined
    let done = false
    function step(timestamp: number) {
        if (start === undefined) {
            start = timestamp
            element.style.transition = transition + ", transform 0s"
        }
        const elapsed = timestamp - start;

        if (previousTimeStamp !== timestamp) {
            const percentTime = elapsed / (duration * 1000)
            const goX = percentTime * moveX
            const goY = percentTime * moveY

            if (percentTime >= 1) {
                element.style.transform = ""
                currEl.rect = element.getBoundingClientRect()
                done = true
            } else {
                element.style.transform = `translate(${moveX - goX}px, ${moveY - goY}px)`
                // ---- 实时更新现在的位置
                currEl.rect = element.getBoundingClientRect()
            }
        }

        previousTimeStamp = timestamp
        // ---- 正常结束 或者 让上一次如果没有进行完的动画提前停止
        if (!done && !currEl.stopTrigger) {
            requestAnimationFrame(step)
        } else {
            element.style.transition = transition
        }
    }
    requestAnimationFrame(step)
}


