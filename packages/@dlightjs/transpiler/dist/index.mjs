import*as l from"@babel/types";import*as k from"@babel/core";import se from"@babel/generator";var d={traverse:k.traverse,generate:n=>se(n).code,parse:n=>k.parse(n,{plugins:[["@babel/plugin-syntax-typescript",{isTSX:!0}],"@babel/plugin-syntax-jsx","@babel/plugin-syntax-do-expressions",["@babel/plugin-proposal-decorators",{legacy:!0}]]})};function T(n,e,r,t){t.body.includes(r)||t.body.unshift(r),r.value.properties.push(l.objectProperty(l.identifier(n),l.arrayExpression(e.map(s=>l.stringLiteral(s)))))}function I(n,e,r){r.body.includes(e)||r.body.unshift(e),!e.value.properties.map(t=>t.key.name).includes(n)&&e.value.properties.push(l.objectProperty(l.identifier(n),l.newExpression(l.identifier("Map"),[])))}function A(n,e){let r=!1,t=n.parentPath;for(;t&&t.node!==e;){if(l.isArrowFunctionExpression(t.node)){r=!0;break}t=t.parentPath}return r}function oe(n){let e=n.parentPath.node;return l.isAssignmentExpression(e)&&e.left===n.node}function ie(n,e){let r=n.node,t=!1,s=n.parentPath;for(;s&&s.node!==e;){if(l.isAssignmentExpression(s.node)){let o=s.node.left,i=r.type===o.type,a=r.property.name===o.property.name;t=i&&a}s=s.parentPath}return t}function D(n,e){return!A(n,e)&&!oe(n)&&!ie(n,e)}function P(n){return d.parse(n).program.body[0].body}function X(n,e,r){return[l.classMethod("get",l.identifier(n),[],e),l.classMethod("set",l.identifier(n),[l.identifier("value")],r)]}function L(n){let e=n.value;n.value={type:"ArrowFunctionExpression",params:[],body:e}}import*as f from"@babel/types";function V(n){let e=n.tag,r=/html\((.+)\)/;return r.test(n.tag)?(n.tag=n.tag.replace(r,"$1"),!0):/^[a-z][a-z0-9]*$/.test(e)?(n.tag=`"${n.tag}"`,!0):!1}function M(n){return`${n}
`}function j(n){return"["+n.map((e,r)=>`_$node${r}`).join(", ")+"]"}var g=class{value="";add(e){this.value+=M(e)}shift(e){this.value=M(e)+this.value}addBody(e){this.value+=e.value}};import*as m from"@babel/types";function $(n){return"["+n.map(e=>'"'+e+'"').join(", ")+"]"}function O(){return Math.random().toString(20).slice(2,8)}function W(n,e,r=[]){let t=d.parse(`(${n})`),s=[];return d.traverse(t,{MemberExpression(o){e.includes(o.node.property.name)&&D(o)&&s.push(o.node.property.name)}}),s=[...new Set([...s,...r])],s}function z(n,e,r=[]){let t=d.parse(`(${n})`),s=[];return d.traverse(t,{Identifier(o){for(let{ids:i,propNames:a}of e)i.includes(o.node.name)&&(A(o)||s.push(...a))}}),s=[...new Set([...s,...r])],s}function H(n){return n.match(/[_$a-zA-Z][_$a-zA-Z0-9]*/g)??[]}function B(n){let e=d.parse(`(${n})`);return m.isMemberExpression(e.program.body[0].expression)}function q(n,e){let r=[],t=d.parse(e);d.traverse(t,{Identifier(o){r.push(o.node.name)}});let s=d.parse(`function tempFunc() {${n}}`);return d.traverse(s,{Identifier(o){if(r.includes(o.node.name)&&!m.isMemberExpression(o.parentPath.node)){let i=m.memberExpression(m.identifier("_$valuedItem"),m.identifier(o.node.name));o.replaceWith(i),o.skip()}}}),d.generate(s.program.body[0].body).trim().replace(/(^\{)|(\}$)/g,"")}function U(n){let e=d.parse(`let _ = ${n}`).program.body[0].declarations[0].init;return!!(m.isArrowFunctionExpression(e)||m.isFunctionExpression(e))}var S=class{depChain;subViews;idDepsArr=[];constructor(e,r){this.depChain=e,this.subViews=r}generate(e){let r=new g;for(let[t,s]of e.entries())r.addBody(this.resolveParserNode(s,t));return r.add(`return ${j(e)}`),r.value}geneDeps(e){return[...new Set([...W(e,this.depChain),...z(e,this.idDepsArr)])]}resolveParserNode(e,r){return this.subViews.includes(e.tag)?this.resolveSubView(e,r):e.tag==="env"?this.resolveEnv(e,r):e.tag==="_"?this.resolveExpression(e,r):e.tag==="if"?this.resolveIf(e,r):e.tag==="for"?this.resolveFor(e,r):e.tag==="_$text"?this.resolveText(e,r):V(e)?this.resolveHTML(e,r):this.resolveCustom(e,r)}resolveIf(e,r){let t=new g,s=`_$node${r}`;t.add(`const ${s} = new _$.IfNode()`);for(let o of e.attr.conditions){t.add(`${s}._$addCond(() => ${o.condition}, () => {`),t.add(this.generate(o.parserNodes));let i=this.geneDeps(o.condition);if(i.length>0){t.add(`}, this, ${$(i)})`);continue}t.add("})")}return t}resolveFor(e,r){let t=new g,s=e.attr.key,o=e.attr.item,i=e.attr.array,a=`_$node${r}`;t.add(`const ${a} = new _$.ForNode()`);let u=this.geneDeps(i);if(u.length>0){t.add(`${a}._$addNodeFunc((_$key, _$idx, node_for) => {`);let _=o.match(/[_$a-zA-Z][_$a-zA-Z0-9]*/g)??[];t.add(`const ${o} = node_for._$getItem(_$key, _$idx)`),t.add("const _$valuedItem = {}");for(let v of _)t.add(`_$valuedItem.${v} = ${v}`);t.add(`node_for._$listen(this, ()=>node_for._$getItem(_$key, _$idx),             ${$(u)}, (_$item) => {`),t.add(`const ${o} = _$item`);for(let v of _)t.add(`_$valuedItem.${v} = ${v}`);t.add("})");let y=new S(this.depChain,this.subViews);y.idDepsArr=[{ids:H(o),propNames:u}];let p=y.generate(e.children);p=q(p,o),t.add(p),t.add("})"),s&&(t.add(`${a}._$addKeyFunc(() => {`),t.add("const keys = []"),t.add(`for (let ${o} of ${i}) {`),t.add(`keys.push(${s})`),t.add("}"),t.add("return keys"),t.add("})")),t.add(`${a}._$addArrayFunc(this, () => (${i}), ${$(u)})`)}else t.add(`${a}._$addNodess(Array.from(${i}).map((${o}) => (() => {`),t.add(this.generate(e.children)),t.add("})()))");return t}resolveText(e,r){let t=new g,s=e.attr._$content,o=this.geneDeps(`${s}`),i=`_$node${r}`;return o.length>0?t.add(`const ${i} = new _$.TextNode(() => ${s}, this, ${$(o)})`):t.add(`const ${i} = new _$.TextNode(${s}, )`),t}resolveHTML(e,r){let t=new g,s=`_$node${r}`;t.add(`const ${s} = new _$.HtmlNode(${e.tag}, )`);for(let{key:o,value:i,nodes:a}of e.attr.props){if(i=this.parsePropNodes(i,a),o==="element"){t.add(`${i} = ${s}._$el`);continue}if(["willAppear","didAppear","willDisappear","didDisappear"].includes(o)){t.add(`${s}._$addLifeCycle(${i}, "${o}")`);continue}o==="_$content"&&(o="innerText");let u=this.geneDeps(i);if(u.length>0){t.add(`${s}._$addProp("${o}", () => (${i}), this, ${$(u)})`);continue}t.add(`${s}._$addProp("${o}", ${i})`)}return e.children.length>0&&(t.add(`${s}._$addNodes((() => {`),t.add(this.generate(e.children)),t.add("})())")),t}resolveCustom(e,r){let t=new g,s=`_$node${r}`;t.add(`const ${s} = new (${e.tag})()`);for(let{key:o,value:i,nodes:a}of e.attr.props){if(i=this.parsePropNodes(i,a),o==="element"){U(i)?t.add(`${s}._$addAfterset(() => (${i})(${s}._$el))`):t.add(`${s}._$addAfterset(() => ${i} = ${s}._$el)`);continue}if(["willMount","didMount","willUnmount","didUnmount"].includes(o)){t.add(`${s}._$addLifeCycle(${i}, "${o}")`);continue}let u=this.geneDeps(i);if(u.length>0){t.add(`${s}._$addProp("${o}", () => (${i}), this, ${$(u)}, ${B(i)})`);continue}t.add(`${s}._$addProp("${o}", ${i})`)}if(e.children.length>0){t.add(`${s}._$addChildren([`);for(let o of e.children)t.add("() => {"),t.addBody(this.resolveParserNode(o,0)),t.add("return _$node0"),t.add("},");t.add("])")}return t}resolveSubView(e,r){let t=new g;return t.add(`const _$node${r} = ${e.tag}()`),t}resolveEnv(e,r){let t=new g,s=`_$node${r}`;t.add(`const ${s} = new _$.EnvNode()`),e.children.length>0&&(t.add(`${s}._$addNodes((() => {`),t.add(this.generate(e.children)),t.add("})())"));for(let{key:o,value:i,nodes:a}of e.attr.props){i=this.parsePropNodes(i,a);let u=this.geneDeps(i);if(u.length>0){t.add(`${s}._$addProp("${o}", () => (${i}), this, ${$(u)}, ${B(i)})`);continue}t.add(`${s}._$addProp("${o}", ${i})`)}return t}resolveExpression(e,r){let t=new g,s=`_$node${r}`;for(let{key:o,value:i,nodes:a}of e.attr.props){if(i=this.parsePropNodes(i,a),o==="_$content"){let _=this.geneDeps(i);_.length>0?t.add(`const ${s} = new _$.ExpressionNode(() => ${i}, this, ${$(_)})`):t.add(`const ${s} = new _$.ExpressionNode(${i}, )`);continue}if(o==="onUpdateNodes"){t.add(`${s}._$onUpdateNodes(${i})`);continue}let u=this.geneDeps(i);if(u.length>0){t.add(`${s}._$addProp("${o}", () => (${i}), this, ${$(u)}, ${B(i)})`);continue}t.add(`${s}._$addProp("${o}", ${i})`)}return t}parsePropNodes(e,r){for(let[t,s]of Object.entries(r)){let o=new g;o.add("((()=>{"),o.add(this.generate(s)),o.add("})())"),e=e.replace('"'+t+'"',o.value)}return e}};function J(n,e,r){return new S(e,r).generate(n)}import*as c from"@babel/types";function ae(){return Math.random().toString(32).slice(2)}function Z(n,e){if(!e)return{key:n,value:!0,nodes:{}};let r=d.parse(d.generate(e)),t={};return d.traverse(r,{DoExpression(s){let o=s.node,i=ae();t[i]=G(o.body.body),s.replaceWith(c.stringLiteral(i))}}),{key:n,value:d.generate(r).replace(/;$/,""),nodes:t}}function de(n){let e={tag:"",attr:{props:[]},children:[]},r=n;for(;r&&r.callee&&r.callee.loc?.start.line!==r.callee.loc?.end.line;){let t=r.arguments[0],s=r.callee.property.name;e.attr.props.push(Z(s,t)),r=r.callee.object}return r.arguments.length>0&&e.attr.props.push(Z("_$content",r.arguments[0])),e.tag=d.generate(r.callee),e}function le(n){return{tag:"_$text",attr:{_$content:d.generate(n)},children:[]}}function pe(n){let e=K(n.tag);Array.isArray(e)||(e=[e]);let r={tag:"_$text",attr:{_$content:d.generate(n.quasi)},children:[]};return[...e,r]}function K(n){return c.isCallExpression(n)?de(n):c.isStringLiteral(n)||c.isTemplateLiteral(n)?le(n):c.isTaggedTemplateExpression(n)?pe(n):{}}function ce(n){let e=d.generate(n.left.declarations[0]),r=d.generate(n.right),t={tag:"for",attr:{item:e,array:r},children:[]},s=n.body.body;return c.isArrayExpression(s[0].expression)&&(t.attr.key=d.generate(s[0].expression.elements[0]),s=s.slice(1)),t.children=E(s),t}function ue(n){return{tag:"if",attr:{conditions:R(n)},children:[]}}function R(n){let e=[],r=d.generate(n.test),t=E(n.consequent.body);return e.push({condition:r,parserNodes:t}),c.isIfStatement(n.alternate)?e.push(...R(n.alternate)):n.alternate&&e.push({condition:!0,parserNodes:E(n.alternate.body)}),e}function E(n){let e=[];for(let r of n)if(c.isExpressionStatement(r)){let t=K(r.expression);Array.isArray(t)||(t=[t]),e.push(...t)}else c.isBlockStatement(r)?e[e.length-1].children=E(r.body):c.isForOfStatement(r)?e.push(ce(r)):c.isIfStatement(r)&&e.push(ue(r));return e}function G(n){return E(n)}var Q=G;import*as x from"@babel/types";function Y(n,e){if(!e)return{key:n,value:!0,nodes:{}};let r=d.parse(d.generate(e)),t={};d.traverse(r,{JSXElement(o){let i=O();t[i]=b([o.node]),o.replaceWith(x.stringLiteral(i))}});let s=d.generate(r).trim().replace(/;$/g," ");return s.trim()===""&&(s='""'),{key:n,value:s,nodes:t}}function fe(n){let e=n.openingElement.name.name,r=[];for(let t of n.openingElement.attributes)t=t,r.push(Y(t.name.name,t.value));return{tag:e,attr:{props:r},children:b(n.children)}}function ge(n){let e=n.value.trim();return e===""?void 0:{tag:"_$text",attr:{_$content:`"${e}"`},children:[]}}function C(n,e){let r=n.openingElement.attributes.find(o=>o.name.name===e);if(!r)return r;let t="",s=r.value;return t=x.isJSXExpressionContainer(s)?d.generate(s.expression):d.generate(s),t}function me(n){return{tag:"if",attr:{conditions:[{condition:C(n,"cond"),parserNodes:b(n.children)}]},children:[]}}function ye(n,e){e.attr.conditions.push({condition:C(n,"cond"),parserNodes:b(n.children)})}function $e(n,e){e.attr.conditions.push({condition:"true",parserNodes:b(n.children)})}function he(n){return{tag:"for",attr:{item:C(n,"let"),array:C(n,"of"),key:C(n,"key")},children:b(n.children)}}function xe(n){return{tag:"_",attr:{props:Y("_$content",n)},children:[]}}function b(n){let e=[];for(let r of n){if(x.isJSXText(r)){let s=ge(r);s&&e.push(s);continue}if(x.isJSXExpressionContainer(r)){e.push(xe(r));continue}if(x.isJSXFragment(r)){e.push(...b(r.children));continue}let t=r.openingElement.name.name;if(t==="if"){e.push(me(r));continue}if(t==="else-if"){ye(r,e[e.length-1]);continue}if(t==="else"){$e(r,e[e.length-1]);continue}if(t==="for"){e.push(he(r));continue}e.push(fe(r))}return e}function be(n){return b([n])}var ee=be;import*as N from"@babel/types";function te(n,e){let r=n.key.name;n.key.name=`_$$${r}`;let t=e.body.indexOf(n),s=P(`
    function ${r}() {
        return this._$$${r}
    }`),o=P(`
    function ${r}(value) {
        if (this._$$${r} === value) return
        this._$$${r} = value
        this._$runDeps("${r}")
    }`),[i,a]=X(r,s,o);e.body.splice(t+1,0,i,a)}function ne(n,e,r){let t=n.key.name,s=e.body.indexOf(n),o=r.toLowerCase(),i=N.classProperty(N.identifier(`_$$${t}`),N.stringLiteral(`_$${o}`));e.body.splice(s,0,i)}function _e(n,e,r){let t=J(Q(n.body.body),e,r);n.body=P(`function tmp() { ${t} }`)}function ve(n,e,r){let t=J(ee(n.value),e,r);n.value=f.arrowFunctionExpression([],P(`function tmp() { ${t} }`))}function re(n,e,r){let t=r==="jsd"?_e:ve,s,o=[];for(let a of n.body)a.decorators?.find(u=>f.isIdentifier(u.expression)&&u.expression.name==="View")?(a.decorators=void 0,o.push(a)):a.key.name==="Body"&&(s=a);let i=o.map(a=>"this."+a.key.name);for(let a of o)t(a,e,i);t(s,e,i)}function Pe(n,e){let r=d.parse(n),t=null,s=null,o=null,i=null,a=[];return d.traverse(r,{ClassDeclaration(y){let p=y.node;if(f.isIdentifier(p.superClass,{name:"View"})){t=p,s=t.body,s.body.unshift(f.classProperty(f.identifier("_$tag"),f.stringLiteral(t.id.name))),i=f.classProperty(f.identifier("_$derivedPairs"),f.objectExpression([])),o=f.classProperty(f.identifier("_$deps"),f.objectExpression([])),a=[];return}},ClassMethod(y){!t||s.body.indexOf(y.node)===s.body.length-1&&re(s,a,e)},ClassProperty(y){if(!t)return;let p=y.node,v=s.body.indexOf(y.node)===s.body.length-1;if(p.decorators?.find(h=>f.isIdentifier(h.expression)&&h.expression.name==="View"))return;let w=[];if(y.scope.traverse(p,{MemberExpression(h){a.includes(h.node.property.name)&&D(h,t)&&w.push(h.node.property.name)}}),w=[...new Set(w)],w.length>0&&(T(p.key.name,w,i,s),I(p.key.name,o,s),L(p),a.push(p.key.name)),p.decorators){for(let h of p.decorators){let F=h.expression.name??h.expression.callee.name;if(["EnvState","PropState","State"].includes(F)){a.push(p.key.name),I(p.key.name,o,s),te(p,s);break}if(["Prop","Env"].includes(F)){a.push(p.key.name),I(p.key.name,o,s),ne(p,s,F);break}}p.decorators=null}v&&re(s,a,e)}}),`import * as _$ from '@dlightjs/dlight';
`+d.generate(r)}export{Pe as parseDlightFile};
